/**
 ******************************************************************************
 * Xenia : Xbox 360 Emulator Research Project                                 *
 ******************************************************************************
 * Copyright 2022 Ben Vanik. All rights reserved.                             *
 * Released under the BSD license - see LICENSE in the root for more details. *
 ******************************************************************************
 */

#include "xesl.xesli"

#include "amd_language.xesli"

push_const_begin_xe(b0, space0)
  // 16 used by the vertex shader (GLSL push constant offsets are across
  // stages).
  block_offset_member_xe(16, c0.x, float2_xe,
                         xe_fsr_easu_input_output_size_ratio)
  block_offset_member_xe(24, c0.z, float2_xe, xe_fsr_easu_input_size_inv)
push_const_end_xe

// FIXME(Triang3l): This approach doesn't work for MSL - the texture must be
// passed explicitly from the entry point's arguments to FsrEasu#F.

// Forward declaration because FsrEasu#F need xe_fsr_easu_source from the entry
// point bindings.
void FsrEasuF(out_param_xe(float3_xe, pixel), uint2_xe pixel_position,
              uint4_xe const0, uint4_xe const1, uint4_xe const2,
              uint4_xe const3);

entry_outputs_begin_xe
  entry_out_target_xe(float4_xe, xe_fsr_easu_color, 0)
entry_outputs_end_stage_inputs_begin_xe
entry_stage_inputs_end_bindings_begin_pixel_xe
  push_const_binding_xe(buffer(0))
  entry_binding_next_xe
  texture_xe(texture_2d_xe, xe_fsr_easu_source, set=0, binding=0, t0, space0,
             texture(0))
  entry_binding_next_xe
  sampler_state_xe(xe_fsr_easu_sampler, set=0, binding=1, s0, space0,
                   sampler(0))
entry_bindings_end_inputs_begin_xe
  entry_in_pixel_coord_xe
entry_inputs_end_code_begin_xe
{
  // FsrEasuCon with smaller push constant usage.
  uint4_xe easu_const_0 =
      uint4_xe(
          float_bits_to_uint_xe(
              push_const_xe(xe_fsr_easu_input_output_size_ratio)),
          float_bits_to_uint_xe(
              0.5f * push_const_xe(xe_fsr_easu_input_output_size_ratio) -
              0.5f));
  uint4_xe easu_const_1 =
      float_bits_to_uint_xe(float4_xe(1.0f, 1.0f, 1.0f, -1.0f) *
                            push_const_xe(xe_fsr_easu_input_size_inv).xyxy);
  uint4_xe easu_const_2 =
      float_bits_to_uint_xe(float4_xe(-1.0f, 2.0f, 1.0f, 2.0f) *
                            push_const_xe(xe_fsr_easu_input_size_inv).xyxy);
  uint4_xe easu_const_3 = uint4_xe(
      float_bits_to_uint_xe(0.0f),
      float_bits_to_uint_xe(4.0f * push_const_xe(xe_fsr_easu_input_size_inv).y),
      0u, 0u);
  FsrEasuF(out_xe(xe_fsr_easu_color).rgb, uint2_xe(in_pixel_coord_xe.xy),
           easu_const_0, easu_const_1, easu_const_2, easu_const_3);
  out_xe(xe_fsr_easu_color).a = 1.0f;
}
entry_code_end_xe

#define A_GPU 1
#include "../../../../third_party/FidelityFX-FSR/ffx-fsr/ffx_a.h"
#define FSR_EASU_F 1
float4_xe FsrEasuRF(float2_xe p) {
  return gather_sep_2d_r_xe(xe_fsr_easu_source, xe_fsr_easu_sampler, p);
}
float4_xe FsrEasuGF(float2_xe p) {
  return gather_sep_2d_g_xe(xe_fsr_easu_source, xe_fsr_easu_sampler, p);
}
float4_xe FsrEasuBF(float2_xe p) {
  return gather_sep_2d_b_xe(xe_fsr_easu_source, xe_fsr_easu_sampler, p);
}
#include "../../../../third_party/FidelityFX-FSR/ffx-fsr/ffx_fsr1.h"
